#!/usr/bin/bash
function makeStandardFormatText()
{
    local -r unformattedText="$1"

    # [[:space:]]  - [ \t\v\f\n\r]   All whitespace chars
    # the output of tr is every [[:space:]]+ (a string of 1 or more of them)
    # is converted to a single ' ' (normal "spacebar")
    # the sed commands subsitutes the beginning of the line with a single space
    # with nothing, and a single space with the end of the line with nothing.
    # since the whole string is single line, this has the effect of removing
    # leading and trailing spaces from the string.
     tr -s '[:space:]' ' ' <<< "${unformattedText}" | sed 's/^ //; s/ $//;'
}

function makeSeperator()
{
	local -r repeatChar="$1"
	local -r count="$2"
	yes "${repeatChar}" | head -n "${count}" | paste -s -d ''
}

function limitStringWidthBlockify()
{
    local -r str="$1"
    local -r length="$2"
    fold -s -w"${length}" <<< "${str}"
}

function generateTrackableEvent()
{
    local -r taskName="$1"
    local -r optionalDescription="$2"
    local -r sepLength="$3"
    local -r maxTaskNameLength=$(( sepLength * 80 / 100 ))
    local -r maxDescriptionLength=$(( sepLength * 75 / 100 ))
    local -r colorTimeName="$(tput setaf 181)"
    local -r colorTaskName="$(tput setaf 168)"
    local -r colorDescriptionName="$(tput setaf 255)"
    local -r defaultTextColor="$(tput sgr0)"

    echo -n "${colorTimeName}$(date +'%T') - ${colorTaskName}"
    limitStringWidthBlockify "${taskName}" "${maxTaskNameLength}"
    if [[ -n "${optionalDescription}" ]]; then
        echo -n "${defaultTextColor}"
        makeSeperator '-' "${sepLength}"
        echo -n "${colorDescriptionName}"
        echo -n "Notes:"
        limitStringWidthBlockify "${optionalDescription}" "${maxDescriptionLength}" | sed 's/^/\t\t/'
    fi
    echo -n "${defaultTextColor}"
    makeSeperator '_' "${sepLength}"
}

function getTodayTaskTrackerFilename()
{
	todoDir="${OG_TRACKER_DIR}" # enviorment variable
	todaysFileName="$(date +'%F-%a').txt"
	echo "${todoDir}/${todaysFileName}"
}

function getElapsedTime()
{
    # NOTE: limit of 365 days - 1 second in elapsed time due to
    # nature of how this solves the problem. Too lazy to roll out
    # my own diff time, especially since more than a couple of days
    # time between task start and end would be rare...

    # start and end are in seconds
    local -r start="$1"
    local -r end="$2"
    local -r diff=$((end - start))
    local -r secInDay=$((60 * 60 * 24))
    local -r secInJanuary=$((secInDay * 31)) # start of unix epoch is on january 1st
    local formatString='%Hh %Mm %Ss'

    if [[ "${diff}" -ge "${secInDay}" ]]; then
        formatString="%d days ${formatString}"
    fi

    if [[ "${diff}" -ge "${secInJanuary}" ]]; then
        formatString="%m months ${formatString}"
    fi

    date --utc --date="@${diff}" +"${formatString}"

    # note about what '@' means (tldr, means seconds since unix epoch): https://unix.stackexchange.com/a/154400
    # insparation for solution: https://stackoverflow.com/a/29269811
}

function checkOutQueuedTask()
{
    # FIFO strucuture, when checking out a task will delelte the task
    local -r queueFile="$1"
    local -r startTimeFile="$2"
    local -r taskFinderString="$3"

    if [[ -z "${taskFinderString}" ]]; then
        echo "$(head -n 1 "${queueFile}") [Elapsed Time: $(getElapsedTime "$(head -n 1 "${startTimeFile}")" "$(date +'%s')")]"
        sed -i '1d' "${queueFile}" "${startTimeFile}"
        return 0
    fi

    # -n to number matches, even though -n shows line number of match, since each
    # task name will be single line with `makeStandardFormatText` the line number
    # of the task name will be the same as the number in the queue
    local -r matchedQueuedTasks=$(grep -in "${taskFinderString}" "${queueFile}")

    if [[ $(wc -l <<< "${matchedQueuedTasks}") -gt 1 ]]; then
        # > $(tty) is for getting output to user! https://stackoverflow.com/a/27777403/15054688
        echo "Multiple tasks containing: \"${taskFinderString}\"! Please choose a specific task." > "$(tty)"
        echo 'Tasks:' > "$(tty)"
        echo "${matchedQueuedTasks}" > "$(tty)"
        read -rp 'Choose a task (number): ' taskNumber # by default output goes to user; don't have to redirect
        echo "$(sed -n "${taskNumber}p" "${queueFile}") [Elapsed Time: $(getElapsedTime "$(sed -n "${taskNumber}p" "${startTimeFile}")" "$(date +'%s')")]"
        sed -i "${taskNumber}d" "${queueFile}" "${startTimeFile}"
        return 0
    fi


}

function addTaskToQueue()
{
    local -r queueFile="$1"
    local -r startTimeFile="$2"
    local -r taskName="$3"

    echo "${taskName}" >> "${queueFile}"
    date +'%s' >> "${startTimeFile}" # unix time in seconds makes easier arithmatic later to figure out elapsed time
}

function help()
{
echo 'ogtracker
A command line time tracker/diary faciliator.


NOTE, a folder must be set asside to put all the files. Folder defined with
exported enviorment variable "OG_TRACKER_DIR"


USAGE:
    ogtracker [OPTION] [TASK_TITLE/TASK_FINDER_STRING] [DESCRIPTION]

    Only one option per ogtracker invocation!


OPTIONS:
    -s, --start, --push) TASK_TITLE [DESCRIPTION]
            Often task involve starting said task and then finishing. In order to avoid
            having to retype the bulk of the task name again when finished, push it
            to the queue to signifiy the start and pop it when you are done.

    -e, --end, --pop) [TASK_FINDER_STRING] [DESCRIPTION]
            Mark the started task as finished. If no positional arguments provided will
            pop off the longest "waiting" queued task (FIFO). The task finder string is
            useful if there are more than one queued up tasks and you want to finish a
            specific task. Just type in a snippet and ogtracker will find the task. If
            there are more than one task with the same snippet, ogtracker will present
            the tasks and ask you to pick one.

    -q, --queue)
            Forgot what you queued up? Take a look with this option.

    -l)
            List out the tracked tasks for today. Equivalent to running ogtracker
            with no arguments.

    --help)
            Lost and confused? Read the help page!

EXAMPLES:
    ogtracker "starting project chem" "isotopes n stuff"
    ogtracker -s "going on a run" "24 miles, one day, light work."
    ogtracker -e
    ogtracker -e "cook" "finished cooking! Note to self: herbs and beef taste amazing!"
    ogtracker -q
    ogtracker -l
    ogtracker
    ogtracker --help
'

}

function displayTodayTracker()
{
    local -r todayTrackerFname="$1"

    if [[ -f "${todayTrackerFname}" ]]; then
        bat "${todayTrackerFname}"
        return 0;
    fi

    local -r errorRed="$(tput setaf 1)"
    local -r defaultTextColor="$(tput sgr0)"

    echo -n "${errorRed}"
    echo 'No tracking has been done for today yet!'
    echo $'Can\'t list out todays tasks if you there aren\'t none!'
    echo 'Look at: ogtracker --help'
    echo 'Try: ogtracker <task name> <descirpiton>'
    echo -n "${defaultTextColor}"
}

function main()
{
    local -r SEPERATOR_LENGTH=65
    local -r QUEUED_TASKS_FILENAME="${OG_TRACKER_DIR}/.queuedTasks"
    local -r START_TIME_QUEUED_TASKS="${OG_TRACKER_DIR}/.startTimeQueuedTask"
    local -r todayTrackerFname="$(getTodayTaskTrackerFilename)"

    # avoids error checking on displaying queue file
    # don't do this with tracker file since checking if the file exists
    # is the mechanisim being used to see if any new addiitions have been
    # made this day
    touch "${QUEUED_TASKS_FILENAME}"
    touch "${START_TIME_QUEUED_TASKS}"

    if [[ $# -eq 0 ]]; then
        displayTodayTracker "${todayTrackerFname}"
        return 0
    fi

    # START: format all arguments
    {
        local unformattedArgs=()
        for arg in "$@"
        do
            unformattedArgs+=("$(makeStandardFormatText "${arg}")")
        done

        # https://stackoverflow.com/a/13762614
        set -- "${unformattedArgs[@]}" # replace old with new args
    }
    # END: format all arguments

    local taskName
    local optionalDescription
    local noNewTaskToAdd=true
    case "$1" in
        -s|--start|--push)
            if [[ $# -lt 2 ]]; then
            echo 'Missing task name!'
            exit 1
            fi

            taskName="$2"
            optionalDescription="$3"
            addTaskToQueue "${QUEUED_TASKS_FILENAME}" "${START_TIME_QUEUED_TASKS}" "${taskName}"
            taskName="STARTED: ${taskName}"
            noNewTaskToAdd=false
            # only add "STARTED: " to task name after it has been added to queue to avoid
            # having "STARTED: " be part of the name when stored for future
            ;;
        -e|--end|--pop)
            if [[ "$(wc -l < "${QUEUED_TASKS_FILENAME}")" -eq 0 ]]; then
                echo $'Error! No task in queue. Please first start/push a task to the queue!'
                exit 2
            fi

            local -r taskFinderString="$2"
            taskName="FINISHED: "
            taskName+="$(checkOutQueuedTask "${QUEUED_TASKS_FILENAME}" "${START_TIME_QUEUED_TASKS}" "${taskFinderString}")"
            optionalDescription="$3"
            noNewTaskToAdd=false
            ;;
        -q|--queue)
            (
                while read -r unixSeconds
                do
                    date --date="@${unixSeconds}" +'%a %F %T'
                done < "${START_TIME_QUEUED_TASKS}"
            ) | paste -d $'\001' - "${QUEUED_TASKS_FILENAME}" | sed $'s/\001/    |    /' | bat
            # hack for extended delimenter https://stackoverflow.com/a/25050586/15054688
            ;;
        -l)
            displayTodayTracker "${todayTrackerFname}"
            ;;
        --help)
            help
            ;;
        --*|-*)
            echo "$1 not an accepted argument!"
            help
            ;;
        *)
            taskName="$1"
            optionalDescription="$2"
            noNewTaskToAdd=false
            ;;
    esac

    if "${noNewTaskToAdd}"; then
        return 0
    fi

    echo "Task added!"
    makeSeperator '_' "${SEPERATOR_LENGTH}"
    generateTrackableEvent \
        "${taskName}" \
        "${optionalDescription}" \
        "${SEPERATOR_LENGTH}" | tee -a "${todayTrackerFname}"
    echo '' >> "${todayTrackerFname}" # I prefer how the speration looks between tasks
}

main "$@"